/**
  ******************************************************************************
  * @file    step_file.c
  * @author  Auto-generated by LINGMA
  * @brief   步数数据文件操作模块
  ******************************************************************************
  */

#include "step_file.h"
#include "step.h"
#include "../ff16/ff.h"
#include <string.h>
#include <stdio.h>
#include <stdint.h>

#ifdef STM32F4XX
#include "stm32f4xx.h"
#endif

// 步数数据文件路径
#define STEP_DATA_FILE "0:steps.dat"

// 定义基本类型
typedef unsigned int    UINT;
typedef uint16_t        WORD;
typedef uint32_t        DWORD;

// 定义NULL宏
#ifndef NULL
#define NULL ((void *)0)
#endif

// 步数数据结构体
typedef struct {
    unsigned long step_count;      // 步数
    uint32_t last_update_time;     // 最后更新时间戳
    uint32_t total_active_seconds; // 累计活跃时间（秒）
    uint16_t checksum;             // 数据校验和
} StepData_TypeDef;

// 声明全局变量
extern unsigned long g_step_count;
extern uint32_t get_systick(void);

/**
 * @brief 计算数据校验和
 * @param data 数据指针
 * @param length 数据长度
 * @return 校验和
 */
static uint16_t Calculate_Checksum(uint8_t *data, uint16_t length)
{
    uint16_t checksum = 0;
    for (uint16_t i = 0; i < length; i++) {
        checksum += data[i];
    }
    return checksum;
}

/**
 * @brief 保存步数数据到文件
 */
void Steps_Save(void)
{
    FIL file;
    FRESULT fr;
    UINT bw;
    StepData_TypeDef step_data;
    
    // 准备步数数据
    step_data.step_count = g_step_count;
    step_data.last_update_time = get_systick() / 1000;  // 转换为秒
    step_data.total_active_seconds = step_data.last_update_time;  // 简化处理
    
    // 计算校验和（不包括checksum字段）
    uint8_t *data_ptr = (uint8_t*)&step_data;
    step_data.checksum = Calculate_Checksum(data_ptr, sizeof(StepData_TypeDef) - sizeof(uint16_t));
    
    // 打开文件用于写入（如果不存在则创建，存在则覆盖）
    fr = f_open(&file, STEP_DATA_FILE, FA_CREATE_ALWAYS | FA_WRITE);
    if (fr != FR_OK) {
        return;
    }
    
    // 写入步数数据
    fr = f_write(&file, &step_data, sizeof(StepData_TypeDef), &bw);
    if (fr != FR_OK || bw != sizeof(StepData_TypeDef)) {
        f_close(&file);
        return;
    }
    
    // 关闭文件
    f_close(&file);
}

/**
 * @brief 从文件加载步数数据
 */
void Steps_Load(void)
{
    FIL file;
    FRESULT fr;
    UINT br;
    StepData_TypeDef step_data;
    
    // 打开文件用于读取
    fr = f_open(&file, STEP_DATA_FILE, FA_READ);
    if (fr != FR_OK) {
        // 文件不存在或其他错误，初始化为0步数
        g_step_count = 0;
        return;
    }
    
    // 读取步数数据
    fr = f_read(&file, &step_data, sizeof(StepData_TypeDef), &br);
    if (fr != FR_OK || br != sizeof(StepData_TypeDef)) {
        f_close(&file);
        g_step_count = 0;
        return;
    }
    
    // 关闭文件
    f_close(&file);
    
    // 计算并验证校验和
    uint8_t *data_ptr = (uint8_t*)&step_data;
    uint16_t calculated_checksum = Calculate_Checksum(data_ptr, sizeof(StepData_TypeDef) - sizeof(uint16_t));
    
    if (step_data.checksum == calculated_checksum) {
        // 校验通过，使用保存的数据
        g_step_count = step_data.step_count;
    } else {
        // 校验失败，使用默认值
        g_step_count = 0;
    }
}
